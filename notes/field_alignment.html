<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.361">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Data Assimilation with field alignment</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="field_alignment_files/libs/clipboard/clipboard.min.js"></script>
<script src="field_alignment_files/libs/quarto-html/quarto.js"></script>
<script src="field_alignment_files/libs/quarto-html/popper.min.js"></script>
<script src="field_alignment_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="field_alignment_files/libs/quarto-html/anchor.min.js"></script>
<link href="field_alignment_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="field_alignment_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="field_alignment_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="field_alignment_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="field_alignment_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
</head><body class="fullcontent">\usepackage{bm}
\newcommand{\norm}[1]{\|#1\|}
\newcommand{\bq}{\bm{q}}
\newcommand{\br}{\bm{r}}
\newcommand{\bs}{\bm{s}}

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>





<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Data Assimilation with field alignment</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<p>Ravella introduit dans son papier</p>
<p><em>Ravela, Sai, Kerry Emanuel, et Dennis McLaughlin. «&nbsp;Data Assimilation by Field Alignment&nbsp;»</em></p>
<p>Une méthode pour tenir compte des erreurs de position en appliquant un déplacement à imposer. La méthode est réalisée en deux étapes. D’abord la détermination d’un champ de déplacement, puis la correction des intensités. L’avantage de cette méthode, et quelle est adaptable à de nombreux filtres, en particulier les filtres d’ensemble.</p>
<p>Il présente tout d’abord en quoi la formulation classique dans un problème de position entraîne une inflation de la matrice de covariance. La matrice issue de la perturbation d’une translation <span class="math inline">\(\lambda\)</span> devient: <span class="math inline">\(C_{\lambda} = C_{XX} + \sigma^2_{\lambda} C_{\Delta\Delta}\)</span> où <span class="math inline">\(\Delta\)</span> est la déviation du gradient (8).</p>
<p>Pour réaliser l’alignement, on part de la formule de Bayes comme pour les filtres d’intensité. Cependant, on introduit une nouvelle variable spatiale <span class="math inline">\(\bq\)</span> vecteur de déplacement. Dans leur travail l’état est défini sur une grille dont les positions sont <span class="math inline">\(\br\)</span>. L’état est donc défini par les valeurs du champ <span class="math inline">\(X = X(\br)\)</span>.</p>
<p>On défini <span class="math inline">\(\bq\)</span> sur la même grille tel que <span class="math inline">\(X(\br - \bq)\)</span> est le déplacement de X par <span class="math inline">\(\bq\)</span>.</p>
<p>On réécrit la formule de Bayes en introduisant cette nouvelle variable</p>
<p><span class="math display">\[
P(X, \bq \mid Y) \propto P(Y \mid X, \bq) P(X^f \mid \bq) P(\bq)
\]</span></p>
<p>La Likelihood <span class="math inline">\(P(Y \mid X, \bq)\)</span> est similaire à la likelihood sur les intensités mais en appliquant au préalable le déplacement de telle sorte que les observations sont conditionnées par <span class="math inline">\(X(\br - \bq)\)</span>.</p>
<p>On suppose donc que <span class="math inline">\(Y = H(X(\br - \bq)) + \bm{\eta} \sim \mathcal{N}(0, R)\)</span>, où les observations restent bien fixes.</p>
<p>De même le prior sur l’intensité est inchangé en considérant au préalable la transformation <span class="math inline">\(\bq\)</span>. Mais il faut remarquer que la matrice de covariance est dépendante de <span class="math inline">\(\bq\)</span>. Dans un cas de filtre d’ensemble il s’agit de calculer la matrice également après transformation.</p>
<p>Finalement le prior sur le déplacement <span class="math inline">\(P(\bq)\)</span> est l’élément aditionnel. Pour cela on introduit une fonction d’énergie, qui va régulariser les déplacements. C’est elle qui introduit un coup de déplacement. On peut penser le champ de déplacement comme un champ d’écoulement lissé. Cette propriété de lissage amene donc à considérer des pénalisations de Tikhonov qui va pénaliser à la fois le gradient et la divergence. Mais on peut tout à fait modifier notre a priori sur la distribution de <span class="math inline">\(\bq\)</span>. La prendre uniform n’apporterait pas d’information, la prendre gaussienne demande de définir une manière appropriée pour la définir. La contrainte ici reste locale mais elle introduit une forte régularité par pénalisation.</p>
<p>En prenant finalement la log likelihood on obtient la fonction de coût associée <span class="math inline">\(J(X, \bq)\)</span>. On remarquera que un terme inhabituel lié à la dépendance de <span class="math inline">\(P\)</span> à <span class="math inline">\(\bq\)</span>.</p>
<p>Ainsi on obtient</p>
<p><span class="math display">\[
J_2(X, \bq) = \frac12 \norm{(X - X^f)(\br - \bq)}^2_{P(\bq)} + \frac12 \norm{Y - H(X(\br - \bq))}^2_{R} + L(\bq) + \frac12 \ln{|B(\bq)|}.
\]</span></p>
<p>Pour résoudre le problème on a besoin de <span class="math inline">\(P(\bq)\)</span> et dériver toute la fonction coût. On peut utiliser pour cela un ensemble comme en EnKF pour l’estimer. Pour cela on suppose connu les déplacements associés à chacun des membres <span class="math inline">\(\bq_s\)</span>. On note <span class="math inline">\(\bp_s = \br_s - \bq_s\)</span>. et on estime donc <span class="math inline">\(B_Q\)</span>. Finalement, on finit par avoir une version Hybrid de la fonction de coût.</p>
<p>Il choisis également de fixer les déplacement dans l’évaluation de <span class="math inline">\(B_Q\)</span> pour éviter de devoir les différentier et modifier dans la version itérative. Il peut ainsi définir les gradients en fonction de <span class="math inline">\(\bq_s\)</span></p>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>